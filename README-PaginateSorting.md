# Pagination and Sorting Implementation

## How Pagination Works

The booking API implements server-side pagination to efficiently handle large datasets without loading all records into memory. Pagination is controlled through two query parameters: `page` (starting from 1) and `pageSize` (number of records per page, capped at 100). When a request is made, the system first counts the total number of records matching any applied filters at the database level, then retrieves only the requested page using SQL LIMIT and OFFSET clauses. The response includes metadata such as the current page number, page size, total record count, and total page count, allowing clients to build pagination controls. Default values are configured through the `PaginationConstants` class, with a default page size of 10 records to balance between performance and usability.

## Supported Filters

The filtering system supports multiple criteria that can be combined to narrow down booking results. Room-based filters include `RoomName` (partial text matching using SQL LIKE) and `Location` (exact match on the room location enum). Time-based filters support `StartDate` and `EndDate` parameters to find bookings that overlap with a specified date range. Additional filters include `IsActiveRoom` to show only bookings in currently active rooms and `Status` to filter by booking status (Confirmed, Cancelled, Pending). All filters are optional and can be combined freely—the system builds a SQL WHERE clause dynamically based on which parameters are provided. Filtering happens entirely at the database level through Entity Framework's IQueryable composition, ensuring efficient query execution without loading unnecessary data into application memory.

## Sorting Capabilities

The API supports sorting bookings by three fields: `Date` (booking start time), `RoomName`, and `CreatedAt` (record creation time). Sorting direction is controlled through the `sortOrder` parameter accepting either "asc" for ascending or "desc" for descending order, with descending as the default. Due to SQLite database limitations that prevent direct ordering by DateTimeOffset columns, the implementation uses the auto-increment `Id` field as a proxy for date-based sorting, which maintains chronological order since newer bookings receive higher IDs. Clients can discover available sorting options through the dedicated `/api/booking/sorting-options` endpoint, and each paginated response includes `sortBy` and `sortOrder` metadata indicating which sort was applied. All sorting operations execute at the database level through SQL ORDER BY clauses, maintaining performance efficiency even with large datasets.

## Performance Considerations

The implementation follows strict performance best practices to ensure scalability and efficiency. All read-only queries use Entity Framework's `AsNoTracking()` method to disable change tracking, reducing memory overhead and improving query performance since returned entities don't need to be monitored for updates. Database operations are composed using IQueryable chains that translate to efficient SQL queries, avoiding the common anti-pattern of calling `ToList()` early and then filtering in memory. Pagination constants are centralized in the `PaginationConstants` class to eliminate hardcoded values and enforce maximum page size limits, preventing clients from requesting excessively large result sets. The entire data pipeline—filtering, sorting, counting, and pagination—executes at the database level, meaning only the final requested page of data is transferred from the database to the application. All repository methods use async/await patterns (`ToListAsync`, `CountAsync`, `FirstOrDefaultAsync`) to prevent thread blocking during database I/O operations, allowing the application to handle concurrent requests efficiently. DTOs are returned from list endpoints rather than full entity objects, reducing payload size and preventing over-fetching of related data.
